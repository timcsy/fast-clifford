# 功能規格書：CGA(n) 統一介面

**功能分支**：`004-cga-unified-interface`
**建立日期**：2025-12-08
**狀態**：草稿
**輸入**：使用者描述：「CGA(n) 統一介面，包含 CGA0D 快速算法、CGA6D+ 運行時算法，以及 Cl(p,q,r) 表示法支援」

## 使用者情境與測試 *(必要)*

### 使用者故事 1 - 統一 CGA 維度選擇 (優先順序: P1)

作為一位使用共形幾何代數的開發者，我希望透過簡單的 `CGA(n)` 介面來指定 CGA 維度，並讓系統自動路由到最適合的算法（n=0-5 使用快速硬編碼算法，n≥6 使用運行時算法），這樣我就可以處理任意維度的 CGA 而不需要擔心實作細節。

**優先順序理由**：這是核心功能，所有其他功能都依賴於此。沒有統一介面的話，使用者必須手動管理不同維度的模組，這容易出錯且繁瑣。

**獨立測試**：可透過對 n=0,1,2,3,4,5,6,7 呼叫 `CGA(n)` 並驗證每個都返回可執行三明治積的代數物件來完整測試。

**驗收情境**：

1. **假設** 函式庫已匯入，**當** 呼叫 `CGA(3)` 時，**則** 返回具備所有標準操作（三明治積、編碼、解碼）的 CGA3D 代數物件
2. **假設** 函式庫已匯入，**當** 呼叫 `CGA(0)` 時，**則** 返回使用快速硬編碼算法的 CGA0D 代數物件
3. **假設** 函式庫已匯入，**當** 呼叫 `CGA(6)` 時，**則** 返回使用運行時算法的 CGA6D 代數物件
4. **假設** 函式庫已匯入，**當** 呼叫 `CGA(10)` 時，**則** 返回使用運行時算法的 CGA10D 代數物件，支援任意高維度

---

### 使用者故事 2 - CGA0D 快速算法 (優先順序: P2)

作為一位開發者，我希望存取快速硬編碼的 CGA0D (Cl(1,1)) 代數實作，這樣我就可以以最佳效能執行 0 維共形幾何操作。

**優先順序理由**：CGA0D 完成了從 0D 到 5D 的快速算法覆蓋，為所有常見使用情境提供一致的高效能層級。

**獨立測試**：可透過建立 CGA0D 馬達和點、執行三明治積，並對照 clifford 函式庫參考值驗證結果來測試。

**驗收情境**：

1. **假設** CGA0D 代數已載入，**當** 從 0D 值編碼一個點時，**則** 返回 2 分量的 UPGC 點
2. **假設** 一個 CGA0D 馬達和點，**當** 執行三明治積時，**則** 結果在數值容差範圍內與 clifford 函式庫參考值相符
3. **假設** CGA0D 操作，**當** 匯出至 ONNX 時，**則** 計算圖中無迴圈操作

---

### 使用者故事 3 - Clifford 簽名表示法 (優先順序: P3)

作為一位數學家或研究者，我希望使用標準 Clifford 表示法 `Cl(p,q,r)` 來直接建立代數，這樣我就可以使用熟悉的數學慣例，並存取任意 Clifford 代數（不限於 CGA）。

**優先順序理由**：這為進階使用者和研究者提供彈性，他們習慣以 Clifford 代數簽名而非 CGA 維度來思考。

**獨立測試**：可透過呼叫 `Cl(4,1,0)` 並驗證返回等同於 CGA3D 的代數來測試。

**驗收情境**：

1. **假設** 函式庫已匯入，**當** 呼叫 `Cl(4, 1, 0)` 時，**則** 返回 CGA3D 代數（因為 CGA3D = Cl(4,1,0)）
2. **假設** 函式庫已匯入，**當** 呼叫 `Cl(4, 1)` 時（r=0 為預設），**則** 返回 CGA3D 代數
3. **假設** 函式庫已匯入，**當** 請求非 CGA 簽名如 `Cl(3, 0, 0)` 時，**則** 發出警告表示這不是 CGA 代數，但仍然建立該代數
4. **假設** 函式庫已匯入，**當** 呼叫 `Cl(3, 0, 1)` 時，**則** 返回具有退化維度的 Clifford 代數

---

### 使用者故事 4 - 高維度運行時 CGA (優先順序: P4)

作為一位探索高維共形幾何的研究者，我希望能使用 CGA6D 及更高維度，並且能在訓練神經網路時使用這些操作，這樣我可以實驗高維幾何變換並整合至深度學習流程。

**優先順序理由**：雖然較不常見，但高維 CGA 對於專門的研究應用是必要的。運行時計算以彈性換取效能，但必須保持 PyTorch 相容性和可微分性。

**獨立測試**：可透過建立 CGA6D 代數，驗證基本操作正確性、梯度反向傳播、以及 ONNX 匯出來測試。測試應保持輕量，不做效能基準比較。

**驗收情境**：

1. **假設** 請求 CGA(6)，**當** 建立代數時，**則** 它具有 256 個 blades (2^8) 且可執行所有標準操作
2. **假設** CGA(6) 代數，**當** 執行三明治積時，**則** 結果在容差範圍內與 clifford 函式庫數值相符
3. **假設** 運行時 CGA 層，**當** 執行 `loss.backward()` 時，**則** 梯度正確傳播至所有輸入張量
4. **假設** 運行時 CGA 層，**當** 匯出至 ONNX 時，**則** 計算圖中無迴圈操作，與硬編碼算法相同標準

---

### 邊界情況

- 當請求 CGA(-1) 時會發生什麼？返回錯誤，表示維度必須為非負數。
- 當請求 CGA(20) 時會發生什麼？允許請求但發出警告，說明極高維度的記憶體和效能影響。
- 系統如何處理無效的 Clifford 簽名？對數學上無效的簽名返回描述性錯誤；對有效但非 CGA 的簽名發出警告。
- 當混合不同 CGA 維度的操作時會發生什麼？返回型別錯誤，表示維度不匹配。

### 測試策略

- **CGA0D-CGA3D**：完整測試（數值正確性、ONNX 匯出、與 clifford 對照）
- **CGA4D-CGA5D**：輕量測試（減少 batch size，跳過耗時的基準比較）
- **CGA6D+（運行時）**：最小測試（僅 CGA6D 作為代表，小 batch size，驗證核心功能）

## 需求 *(必要)*

### 功能需求

#### 統一介面

- **FR-001**：函式庫必須提供 `CGA(n)` 工廠函式，為指定的歐幾里得維度 n 返回代數物件
- **FR-002**：函式庫必須自動將 n=0-5 的 `CGA(n)` 路由至硬編碼快速算法
- **FR-003**：函式庫必須自動將 n≥6 的 `CGA(n)` 路由至運行時算法
- **FR-004**：所有 CGA 代數物件無論底層算法為何，都必須實作相同的抽象介面

#### CGA0D 快速算法

- **FR-005**：函式庫必須提供具有 4 個 blades 的硬編碼 CGA0D (Cl(1,1)) 代數
- **FR-006**：CGA0D 必須支援 2 分量 UPGC 點表示
- **FR-007**：CGA0D 必須支援 2 分量馬達表示
- **FR-008**：CGA0D 操作必須可匯出至 ONNX 且無迴圈操作

#### Clifford 表示法

- **FR-009**：函式庫必須提供 `Cl(p, q, r=0)` 工廠函式用於直接建立 Clifford 代數
- **FR-010**：函式庫必須自動識別 Cl(n+1,1,0) 簽名為 CGA，並路由至對應的快速或運行時算法
- **FR-011**：當請求非 CGA 簽名時，函式庫必須發出警告（非錯誤），但仍建立該代數
- **FR-012**：函式庫必須支援任意有效 (p,q,r) 的通用 Clifford 代數，包含退化維度 r>0

#### 運行時算法

- **FR-013**：運行時算法必須正確計算任意維度的幾何積
- **FR-014**：運行時算法必須正確計算任意維度的三明治積
- **FR-015**：運行時算法必須使用延遲初始化，將計算延後至首次使用時
- **FR-016**：運行時算法必須快取計算結果以供重複使用
- **FR-017**：運行時算法必須完全使用 PyTorch 張量操作實作，確保可微分性
- **FR-018**：運行時算法必須支援 `torch.autograd`，可在訓練時反向傳播梯度
- **FR-019**：運行時算法必須可匯出至 ONNX 且無迴圈操作（與硬編碼算法相同標準）
- **FR-020**：運行時算法必須在運行時動態展開操作，而非使用迴圈迭代

#### 共用介面

- **FR-021**：所有代數必須提供 `upgc_encode()` 用於歐幾里得至 UPGC 轉換
- **FR-022**：所有代數必須提供 `upgc_decode()` 用於 UPGC 至歐幾里得轉換
- **FR-023**：所有代數必須提供 `sandwich_product_sparse()` 用於高效 M × X × M̃
- **FR-024**：所有代數必須提供 `geometric_product_full()` 用於完整幾何積
- **FR-025**：所有代數必須提供 `reverse_full()` 和 `reverse_motor()` 操作
- **FR-026**：所有代數必須提供對應的層類別用於神經網路

### 關鍵實體

- **CGAAlgebraBase**：定義所有 CGA 代數共用介面的抽象基底類別。包含維度資訊屬性（euclidean_dim、blade_count、point_count、motor_count）以及所有操作的抽象方法。

- **HardcodedCGAWrapper**：將現有 cga0d-cga5d 模組適配至統一介面的包裝類別。將模組函式映射至抽象介面方法。

- **RuntimeCGAAlgebra**：使用運行時計算的 ≥6 維度具體實作。使用現有 cga_factory 基礎設施動態生成代數參數。

- **CGA**：將維度請求路由至適當實作的工廠函式/類別。

- **Cl**：通用 Clifford 代數工廠函式，接受 (p, q, r) 簽名。若為 CGA 簽名則自動路由至 CGA 實作。

## 成功標準 *(必要)*

### 可衡量成果

- **SC-001**：開發者可透過單一統一的 `CGA(n)` 介面存取任意 CGA 維度（0 至任意高）
- **SC-002**：CGA0D 至 CGA5D 操作維持現有效能基準（無退化）
- **SC-003**：運行時算法操作產生數值正確的結果，以 CGA6D 為代表測試，與 clifford 函式庫相符，誤差在 1e-5 容差內（使用小 batch size 保持測試快速）
- **SC-004**：所有 CGA 操作（包含運行時算法）可匯出至 ONNX 且無迴圈操作
- **SC-005**：透過統一介面，100% 的現有 cga1d-cga5d 測試持續通過
- **SC-006**：API 在所有維度間保持一致 — 相同的方法名稱、相同的參數慣例
- **SC-007**：非 CGA Clifford 代數可透過 `Cl(p, q, r)` 建立，並附帶適當警告
- **SC-008**：所有代數操作（包含運行時算法）支援 PyTorch 自動微分，可在訓練時反向傳播梯度

## 假設

- 現有 cga1d-cga5d 模組穩定且經過良好測試
- cga_factory.py 基礎設施能夠為任意維度生成正確的代數參數
- 維度 ≥6 的效能不是關鍵（研究/實驗性使用情境），但功能完整性必須與硬編碼版本相同
- 請求非 CGA 代數的使用者了解他們在主要使用情境之外
- 運行時算法可透過動態展開（而非迴圈）實現無迴圈 ONNX 匯出

## 範圍邊界

**範圍內**：
- CGA(n) 統一工廠介面
- Cl(p, q, r) 通用 Clifford 代數工廠
- CGA0D 硬編碼快速算法
- CGA6D+ 運行時算法（支援 PyTorch 可微分、ONNX 無迴圈匯出）
- 通用 Clifford 代數支援（附警告）
- 所有維度的訓練時反向傳播支援

**範圍外**：
- 運行時代數的 MPS/CUDA 特定加速
- 運行時代數的 JIT 編譯優化
- 新硬編碼維度的自動程式碼生成
- 對現有 cga1d-cga5d 模組 API 的破壞性變更
