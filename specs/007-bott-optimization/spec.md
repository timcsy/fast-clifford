# 功能規格：Bott 週期性優化

**功能分支**: `007-bott-optimization`
**建立日期**: 2025-12-19
**狀態**: 草稿
**輸入**: 使用者描述: "透過減少預生成代數（只保留 p>=q 且 p+q<8 的情況），使用 Bott 週期性處理更高維度，並採用張量加速的 16×16 矩陣運算來優化 Clifford 代數儲存。不需要向後相容。"

## 使用者情境與測試 *(必要)*

### 使用者故事 1 - 減少儲存空間 (優先級: P1)

開發者安裝 fast-clifford 函式庫時，發現套件大小顯著減少（從約 600MB 降至約 25MB），使安裝更快、減少磁碟使用量，同時維持所有 Clifford 代數運算的完整功能。

**此優先級的原因**: 減少儲存空間是此功能的主要目標。較小的套件大小可讓所有使用者在安裝後立即受益。

**獨立測試**: 可透過測量優化後的套件大小並驗證所有代數運算仍正常運作來完整測試。

**驗收情境**:

1. **假設** 已安裝優化後的函式庫，**當** 測量 `fast_clifford/algebras/generated/` 目錄大小時，**則** 總大小應低於 30MB（從約 600MB 減少）
2. **假設** 優化後的函式庫，**當** 計算預生成的代數模組數量時，**則** 恰好存在 20 個代數（p >= q 且 p+q < 8）
3. **假設** 優化後的函式庫，**當** 直接建立 Cl(3,0) 或 Cl(4,1) 時，**則** 它們從預生成的硬編碼模組載入，效能不會降低

---

### 使用者故事 2 - 負號簽章代數存取 (優先級: P2)

研究者想使用 Cl(1,3)（時空物理中常用的代數）或 Cl(0,4)（四元數的直接推廣）。系統提供完整的 p < q 代數支援，透過直接生成所有 36 個代數（p+q < 8），確保正確的度量簽章。

**此優先級的原因**: p < q 代數對物理學和數學應用至關重要，必須提供正確的度量簽章。

**獨立測試**: 可透過建立 p < q 的 Cl(p,q) 並驗證所有基底向量平方符合正確簽章來完整測試。

**實作說明**: 原始計畫提出使用 SymmetricClWrapper 將 Cl(p,q) 映射到 Cl(q,p)。然而，經過數學分析發現此方法**不可行**：
- Cl(p,q) 和 Cl(q,p) 當 p ≠ q 時**不是同構**的 Clifford 代數
- 它們有不同的度量簽章，無法透過索引重排來轉換
- 例如：Cl(0,4) 所有基底向量平方為 -1，而 Cl(4,0) 所有基底向量平方為 +1
- 沒有任何索引排列能將 +1 變為 -1

因此，採用直接生成所有 36 個代數的策略，儲存空間仍可達到 95% 的減少目標（約 27MB vs 602MB）。

**驗收情境**:

1. **假設** 優化後的函式庫，**當** 建立 Cl(1,3) 時，**則** 代數成功建立為直接硬編碼模組
2. **假設** Cl(1,3)，**當** 計算 e1*e1 時，**則** 結果等於 +1（p=1 正號簽章的基底）
3. **假設** Cl(0,4)，**當** 計算 e1*e1（負號簽章的基底向量）時，**則** 結果等於 -1（所有基底都是 q 型）

---

### 使用者故事 3 - 高維代數運算 (優先級: P2)

從事高維 Clifford 代數（p+q >= 8）研究的研究者可以建立並操作像 Cl(10,0) 或 Cl(17,0) 這樣的代數。系統使用 Bott 週期性將這些分解為可管理的基底代數加上矩陣表示，提供正確的結果並比樸素實作更好的效能。

**此優先級的原因**: Bott 週期性使得支援任意維度的代數成為可能，而不會產生指數級的儲存增長，這是函式庫的關鍵數學特性。

**獨立測試**: 可透過建立高維代數並驗證基底向量屬性和幾何積來完整測試。

**驗收情境**:

1. **假設** 優化後的函式庫，**當** 建立 Cl(10,0) 時，**則** 代數使用 Bott 週期性建立，基底為 Cl(2,0)，矩陣表示為 16×16
2. **假設** Cl(10,0)，**當** 計算 e1*e1 和 e2*e2 時，**則** 兩個結果都等於 +1（正確的正號簽章）
3. **假設** Cl(17,0)（需要兩次 Bott 週期），**當** 建立代數時，**則** 它使用基底 Cl(1,0)，矩陣表示為 256×256

---

### 使用者故事 4 - 加速的 Bott 運算 (優先級: P3)

使用高維 Clifford 代數進行幾何深度學習的機器學習研究者，相比樸素的 Python 迴圈實作，體驗到顯著更快的幾何積運算，使得在訓練流程中實際使用 Bott 週期性代數成為可能。

**此優先級的原因**: 效能優化增強了計算密集型應用的可用性，但次於正確性和儲存減少。

**獨立測試**: 可透過對 Bott 代數的幾何積運算進行基準測試，並與先前的迴圈實作比較來完整測試。

**驗收情境**:

1. **假設** 使用 Bott 週期性建立的 Cl(10,0)，**當** 執行 1000 次幾何積時，**則** 運算完成速度至少比 Python 迴圈實作快 10 倍
2. **假設** 張量加速實作，**當** 執行幾何積時，**則** 結果與參考實作在數值上相同
3. **假設** 形狀為 (100, 1024) 的批次輸入，**當** 在 Cl(10,0) 上執行批次幾何積時，**則** 運算有效利用張量平行化

---

### 邊界情況

- 建立 Cl(0,0) 時會發生什麼？純量代數應正確運作，只有 1 個 blade。
- 當 p+q = 7（最大硬編碼維度）時會發生什麼？代數應使用硬編碼模組，而非 Bott 週期性。
- 當 p+q = 8（最小 Bott 維度）時會發生什麼？代數應使用 Bott 週期性，週期數為 1。
- 系統如何處理 Cl(24,0)（三次 Bott 週期）？應分解為 Cl(0,0) 加上 4096×4096 矩陣。
- 當建立 p < q 且 p+q >= 8 的 Cl(p,q) 時會發生什麼？直接使用 Bott 週期性分解。例如：Cl(2,10) → Bott 分解為 Cl(2,2) ⊗ M₁₆(ℝ)。

## 需求 *(必要)*

### 功能需求

#### 儲存減少

- **FR-001**: 系統必須將預生成代數減少為僅滿足 p+q < 8 的所有代數（包含 p < q）
- **FR-002**: 系統必須在優化後恰好維護 36 個預生成代數模組（所有 p+q < 8 的組合）
- **FR-003**: 系統必須刪除所有 p+q >= 8 的預生成代數（19 個模組）
- **FR-004**: [已移除] ~~系統必須刪除所有 p < q 的預生成代數~~ - 經數學分析後確定需保留

#### 負號簽章代數支援（修訂）

> **重要說明**: 原始設計 FR-005 至 FR-008 提出的 SymmetricClWrapper 方法經數學分析證明**不可行**。
> Cl(p,q) 和 Cl(q,p) 當 p ≠ q 時不是同構的 Clifford 代數，因為它們的度量簽章不同。
> 例如：Cl(0,4) 中 e_i² = -1，而 Cl(4,0) 中 e_i² = +1，無法透過索引重排轉換。
> 因此改為直接生成所有 36 個代數。

- **FR-005**: [已移除] ~~系統必須提供 SymmetricClWrapper~~ - 數學上不可行
- **FR-006**: [已移除] ~~SymmetricClWrapper 必須正確轉換基底向量索引~~ - 數學上不可行
- **FR-007**: 系統必須為所有 p < q 代數提供正確的度量簽章（透過直接硬編碼實作）
- **FR-008**: 當 p+q < 8 時，系統必須對所有 Cl(p,q)（包含 p < q）使用硬編碼模組

#### Bott 週期性

- **FR-009**: 系統必須對所有 p+q >= 8 的代數使用 Bott 週期性
- **FR-010**: 系統必須使用以下公式正確分解簽章：當 p+q >= 8 時，從 p 或 q 減去 8
- **FR-011**: 系統必須支援多重 Bott 週期（例如 Cl(17,0) → Cl(1,0)，k=256）
- **FR-012**: 系統必須計算矩陣大小為 16^週期數，其中週期數是套用減法的次數
- **FR-013**: 系統必須正確處理 Bott 分解中的混合簽章（例如 Cl(10,2) → Cl(2,2)）

#### 張量加速

- **FR-014**: 系統必須預計算基底代數乘法表，作為形狀 (n, n, n) 的 3D 張量
- **FR-015**: 系統必須使用張量運算而非 Python 迴圈來實作幾何積
- **FR-016**: 系統必須支援任意批次維度的批次運算
- **FR-017**: 系統必須實作以下運算的張量加速版本：geometric_product、outer、inner、reverse、conjugate

#### 閾值更新

- **FR-018**: 系統必須將 HARDCODED_THRESHOLD 從 512 更新為 128（p+q < 8）
- **FR-019**: 系統必須更新 Cl() 工廠以根據新閾值進行路由

#### 不向後相容

- **FR-020**: 系統不得維護與已刪除代數的向後相容性
- **FR-021**: 系統不得為依賴已刪除代數的程式碼提供遷移路徑

### 關鍵實體

- **HardcodedClWrapper**: 為所有 p+q < 8 的預生成代數模組提供包裝（包含 p < q）
- ~~**SymmetricClWrapper**: 當 p < q 時將 Cl(p,q) 映射到 Cl(q,p)~~ **[已移除]**: 數學上不可行
- **BottPeriodicityAlgebra**: 使用 Bott 週期性定理分解高維代數
- **乘法表**: 形狀 (n, n, n) 的 3D 張量，儲存預計算的基底代數乘積

## 成功標準 *(必要)*

### 可衡量的成果

- **SC-001**: 預生成代數儲存減少至少 95%（從約 600MB 減少到低於 30MB）
- **SC-002**: 優化後所有現有測試繼續通過
- **SC-003**: 負號簽章代數（p < q）運算產生與 clifford 函式庫匹配的結果，容差在 1e-6 以內
- **SC-004**: Bott 週期性幾何積執行速度至少比 Python 迴圈基準快 10 倍
- **SC-005**: Cl(10,0) 運算的記憶體使用量保持在理論最小值的 2 倍以內
- **SC-006**: 函式庫對所有標準使用情況（VGA、CGA、PGA）保持完整功能

## 假設

- clifford 函式庫（pip 套件）可用於驗證測試
- ~~Cl(p,q) ≅ Cl(q,p) 作為具有適當同構的抽象代數~~ **[錯誤假設已撤銷]**: Cl(p,q) 和 Cl(q,p) 當 p ≠ q 時不是 Clifford 代數同構，因為度量簽章不同
- 使用者主要使用常見代數（VGA 1-7、CGA 1-5），這些都在 p+q < 8 閾值內
- 張量運算為矩陣運算提供足夠的效能
- 沒有外部依賴於生成代數的特定檔案結構
- 直接生成 36 個代數（~27MB）仍符合「顯著減少儲存」的目標（相比原始 602MB，減少 95.5%）
